# 题解

## 208. 实现 Trie (前缀树)

> [题目描述](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

**题目解法:** 该题目是一个典型的实现字典树，字典树的定义我们已经在简要说明中提到，这里我们只需要实现字典树的插入、字符串查找、字符串前缀查找即可.

[rust版本](../../../codes/rust/208.实现-trie-前缀树.rs) |
[java版本](../../../codes/java/208.实现-trie-前缀树.java) |
[golang版本](../../../codes/golang/208.实现-trie-前缀树.go) |
[python版本](../../../codes/python/208.实现-trie-前缀树.py)

</br>

## 212. 单词搜索 II

> [题目描述](https://leetcode-cn.com/problems/word-search-ii/)

**题目解法:** 该题目可以通过回溯 + 集合的方式解决，即先将要查找的单词构成一个集合，然后从board的第一个单词出发，往上、下、左、右四个方向探索单词，如果单词在规定长度内并且在集合中存在，那么就将搜索到的单词加入到结果集中，然后继续下一个单词的回溯。

相比于上一种方法，我们可以将集合更改为字典树来进一步优化查找效率, 因为集合的方式意味着我从board中的一个单词回溯查找直到累积到10个单词后才会停止，而字典树的方式可以在累积的单词如果在字典树中找不到匹配，那么就直接停止回溯，相比之下剪枝效果更好。

[rust版本](../../../codes/rust/212.单词搜索-ii.rs) |
[java版本](../../../codes/java/212.单词搜索-ii.java) |
[golang版本](../../../codes/golang/212.单词搜索-ii.go) |
[python版本](../../../codes/python/212.单词搜索-ii.py)

## 648. 单词替换

> [题目描述](https://leetcode-cn.com/problems/replace-words/)

**题目解法:** 该题目提示了词根 + 继承词组成了一个较长的单词，其实就暗示了前缀树（字典树）的查询，算法思路大致如下:

1. 首先对词典中的单词添加到字典树中
2. 通过空格分割句子，对分割后的每一个单词进行切片分割[0..1]、[0..2]、......
3. 将切片后的单词在字典树中查找，如果找到了就直接替换，否则就继续切片知道单词结束,循环处理直到处理完所有单词

[rust版本](../../../codes/rust/648.单词替换.rs) |
[java版本](../../../codes/java/648.单词替换.java) |
[golang版本](../../../codes/golang/648.单词替换.go) |
[python版本](../../../codes/python/648.单词替换.py)
