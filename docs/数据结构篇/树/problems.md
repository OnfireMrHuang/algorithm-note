# 题解

## 94. 二叉树的中序遍历

> [题目描述](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

**题目解法:** 该题目正如简要说明中深度优先遍历的一样，先访问左子树，再访问根节点，最后访问右子树。因此，我们可以使用递归的方式来实现该题目。

[rust版本](../../../codes/rust/94.二叉树的中序遍历.rs) |
[java版本](../../../codes/java/94.二叉树的中序遍历.java) |
[golang版本](../../../codes/golang/94.二叉树的中序遍历.go) |
[python版本](../../../codes/python/94.二叉树的中序遍历.py)

</br>

## 96. 不同的二叉搜索树

> [题目描述](https://leetcode-cn.com/problems/unique-binary-search-trees/)

</br>

## 98. 验证二叉搜索树

> [题目描述](https://leetcode-cn.com/problems/validate-binary-search-tree/)

</br>

## 99. 恢复二叉搜索树

> [题目描述](https://leetcode-cn.com/problems/recover-binary-search-tree/)

</br>

## 102. 二叉树的层序遍历

> [题目描述](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

</br>


## 104. 二叉树的最大深度

> [题目描述](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

</br>

## 105. 从前序与中序遍历序列构造二叉树

> [题目描述](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

</br>

## 112. 路径总和

> [题目描述](https://leetcode-cn.com/problems/path-sum/)

</br>

## 113. 路径总和 II

> [题目描述](https://leetcode-cn.com/problems/path-sum-ii/)

</br>

## 437. 路径总和 III

> [题目描述](https://leetcode-cn.com/problems/path-sum-iii/)

</br>

## 124. 二叉树中的最大路径和

> [题目描述](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

</br>

## 226. 翻转二叉树

> [题目描述](https://leetcode-cn.com/problems/invert-binary-tree/)

</br>

## 235. 二叉搜索树的最近公共祖先

> [题目描述](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

</br>

## 236. 二叉树的最近公共祖先

> [题目描述](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

</br>

## 449. 序列化和反序列化二叉搜索树

> [题目描述](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/)

</br>

## 743. 网络延迟时间

> [题目描述](https://leetcode-cn.com/problems/network-delay-time/)

</br>
