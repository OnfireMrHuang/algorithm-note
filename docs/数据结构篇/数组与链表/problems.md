# 题解

## 两数之和

**题目描述**: 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

**题目解法**: 遍历给定的数组，使用哈希表存储每一个(数值: 下标)的KV对, 然后再次遍历数组，通过查找哈希表中是否存在key为 `target - nums[i]` 的值，如果存在则返回对应的下标即可。

[rust版本](../../../codes/rust/1.两数之和.rs) |
[java版本](../../../codes/java/1.两数之和.java) |
[golang版本](../../../codes/golang/1.两数之和.go) |
[python版本](../../../codes/python/1.两数之和.py)

## 合并区间

**题目描述**: 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**题目解法**: 首先可以对给定的区间数组intervals先排序(按照start), 重叠的区间肯定选start最小的，而end选最大的，所以我们只需要遍历区间数组，每个区间和上一个区间对比是否重叠，如果重叠则更新end, 不重叠则将上一个区间加入结果数组中。

[rust版本](../../../codes/rust/56.合并区间.rs) |
[java版本](../../../codes/java/56.合并区间.java) |
[golang版本](../../../codes/golang/56.合并区间.go) |
[python版本](../../../codes/python/56.合并区间.py)

## 插入区间

**题目描述**: 给你一个无重叠的，按照区间起始端点排序的区间列表。在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）

**题目解法**: 对于一个已经按照区间起始端点排序好的区间列表，当要插入一个新的区间时，对比列表中的一个区间有三种情况:

1. 新区间和当前区间不重叠，同时新区间在当前区间左侧，那么在未插入过的情况下，直接将新区间插入到当前区间左侧即可。
2. 新区间和当前区间不重叠，同时新区间在当前区间右侧，那么则继续遍历下一个区间。
3. 新区间和当前区间重叠，那么则合并两个区间，同时将新区间的start和end更新，然后继续遍历下一个区间。
4. 如果遍历完所有区间都没有插入过，说明新区间是在最后一个区间的右侧，那么直接将新区间插入到最后即可。

[rust版本](../../../codes/rust/57.插入区间.rs) |
[java版本](../../../codes/java/57.插入区间.java) |
[golang版本](../../../codes/golang/57.插入区间.go) |
[python版本](../../../codes/python/57.插入区间.py)

## 缺失的第一个正数

**题目描述**: 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

**题目解法**: 该题目明确要求时间复杂度为\(O(n)\)并且只使用常数级别的额外空间，我们假设 nums 中的最大值为max_num，那么就可以将nums扩展为长度为max_num的数组，然后想办法让数组中的数值与下标值相等，最终找到第一个不相等的下标就是最小的正整数。
例子:
比如对于数组nums = [1,2,0], 其中nums[0] = 1, nums[1] = 2, nums[2] = 0
我们将每个下标和数值按照条件对应起来(我们规定下标 = 数值 -1)，步骤如下:

1. 我们找到下标为0的值为1, nums[nums[0]-1] = nums[0], 符合条件，此时数组为[1,2,0]
2. 我们继续找到下标为1的值为2, nums[nums[1]-1] = nums[1], 符合条件，此时数组为[1,2,0]
3. 我们继续找到下表为2的值为0, 0不在有效范围内，不符合条件，所以保持不变，最终数组为[1,2,0]
4. 重新再遍历数组，找到下标为2的值不符合条件，那么最小正整数位(2 + 1) = 3.

其中我们并不需要将数组大小扩展到max_num, 因为最小正整数肯定在[1, max_num + 1]之间，所以对于值为负数或者超过数组长度的数值我们不交换，直接跳过即可。 其中我们需要注意的是，我们判断依据是nums[nums[i]-1] 是否等于nums[i], 是因为我们需要当前i位置的值所对应的下标的值一定要等于i位置的值。

[rust版本](../../../codes/rust/41.缺失的第一个正数.rs) |
[java版本](../../../codes/java/41.缺失的第一个正数.java) |
[golang版本](../../../codes/golang/41.缺失的第一个正数.go) |
[python版本](../../../codes/python/41.缺失的第一个正数.py)
