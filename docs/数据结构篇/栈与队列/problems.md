# 题解

## 20.有效的括号

**题目描述**:  给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串`s`，判断字符串是否有效.

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

示例:

> 输入：s = "()[]{}"
> 输出：true

**题目解法**: 该题目使用栈来解决，当遇到左括号时入栈`stack`，遇到右括号时出栈`stack`，对比是否左右匹配(如果不匹配那就无效)；最后再查看`stack`是否还有括号，没有则有效,否则无效.

[rust版本](../../../codes/rust/20.有效的括号.rs) |
[java版本](../../../codes/java/20.有效的括号.java) |
[golang版本](../../../codes/golang/20.有效的括号.go) |
[python版本](../../../codes/python/20.有效的括号.py)

<br>

## 224.基本计算器

**题目描述**: 给你一个字符串表达式，请你实现一个基本计算器来计算并返回它的值。

注意: 不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。

提示:

1. 1 <= s.length <= 3 * 105
2. s 由数字、'+'、'-'、'('、')'、和 ' ' 组成
3. s 表示一个有效的表达式
4. '+' 不能用作一元运算(例如， "+1" 和 "+(2 + 3)" 无效)
5. '-' 可以用作一元运算(即 "-1" 和 "-(2 + 3)" 是有效的)
6. 输入中不存在两个连续的操作符
7. 每个数字和运行的计算将适合于一个有符号的 32位 整数

示例:

> 输入：s = "1 + 1"
> 输出：2

**题目解法**:

下面是`labuladong`的题解思路，很清晰，直接引用了:
[计算器解题思路](https://labuladong.github.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-shi--24fe4/)

[rust版本](../../../codes/rust/224.基本计算器.rs) |
[java版本](../../../codes/java/224.基本计算器.java) |
[golang版本](../../../codes/golang/224.基本计算器.go) |
[python版本](../../../codes/python/224.基本计算器.py)

<br>

## 341.扁平化嵌套列表迭代器

**题目描述**: 给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。

实现扁平迭代器类 NestedIterator ：

- NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器。
- int next() 返回嵌套列表的下一个整数。
- boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false

你的代码将会用下述伪代码检测：

```text
initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
```

如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。

示例:

```text
输入：nestedList = [[1,1],2,[1,1]]
输出：[1,1,2,1,1]
解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。
```

**题目解法**: 该题目我们知道输入的是一个嵌套数值列表，当我们迭代遍历一个列表时，如果遇到的是一个数字，则输出数字，如果遇到的是一个列表，则可以递归该列表将其展平为数字列表，再输出第一个数字。

我们可以利用hasNext方法，对列表优先展平，这样在next方法中，我们就可以直接输出第一个数字了。

[rust版本](../../../codes/rust/341.扁平化嵌套列表迭代器.rs) |
[java版本](../../../codes/java/341.扁平化嵌套列表迭代器.java) |
[golang版本](../../../codes/golang/341.扁平化嵌套列表迭代器.go) |
[python版本](../../../codes/python/341.扁平化嵌套列表迭代器.py)

<br>

## 621.任务调度器

**题目描述**: 给你一个用字符数组`tasks`表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个 相同种类 的任务之间必须有长度为整数`n`的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的 最短时间 。

示例:

> 输入：tasks = ["A","A","A","B","B","B"], n = 2
> 输出：8
> 解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
> 在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。

提示:

1. 1 <= task.length <= 104
2. tasks[i] 是大写英文字母
3. n 的取值范围为 [0, 100]

**题目解法**: 我们可以考虑先将同类型的`task`放入到一个队列中，这样就有多个不同类型任务的队列，然后对比`n+1`和队列数的大小(之所以是n+1是因为n是间隔大小，就比如1和3的间隔是1，但是1和3的差值是2):

- 如果`n+1`大于等于队列数，那么最短时间就是n * (最大的队列高度-1) + 最大队列的高度一层的剩余任务数.(同一类任务必须间隔n，所以除了最后一层，其余层都是固定的`n+1`)
- 如果`n+1`小于队列数，我们可以将超过`n+1`的队列中的任务插入到其他队列中, 此时会出现两种情况:
  - 第一种情况: 插入队列后的任务均匀分布，那么最短时间就是`tasks.len()`
  - 第二种情况: 插入队列后的任务不均匀分布，比如某一类任务数远大于其他类任务，那么最短时间就是`n * (最大的队列高度-1) + 最大队列的高度一层的剩余任务数`

示例图:



[rust版本](../../../codes/rust/621.任务调度器.rs) |
[java版本](../../../codes/java/621.任务调度器.java) |
[golang版本](../../../codes/golang/621.任务调度器.go) |
[python版本](../../../codes/python/621.任务调度器.py)