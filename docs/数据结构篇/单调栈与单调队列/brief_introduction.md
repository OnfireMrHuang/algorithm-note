# 单调栈与单调队列

## 单调栈

栈的原理我们在 [栈与队列](../栈与队列/brief_introduction.md) 中介绍过了，这是一种遵循先入先出的数据结构，底层可以通过数组或者链表实现。那么单调栈在此基础上追加了一种特性，就是栈内元素是单调递增或者单调递减的。

**举一个经典应用例子**:

假设我们有一个数组，`[2,1,2,4,3]`, 我们希望从左到右找到每个元素右边第一个比它大的元素，所以返回的数组是`[4,2,4,-1,-1]`。因为第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。

这个例子我们当然可以使用暴力查询的方式找到答案，但是这样的解法时间复杂度太高,是`O(n^2)`。我们可以使用单调栈来解决这个问题，单调栈的解法是`O(n)`的。

单调栈解法:

```python
def nextGreaterElement(nums):
	n = len(nums)
	# 定义一个等长的数组，用来存储答案
	res = [0] * n
	# 定义一个单调栈
	s = []
	# 逆序遍历列表
	for i in range(n - 1, -1, -1):
		# 如果单调栈中有元素，查看栈顶元素是否比当前元素小，如果是则弹出，知道遇到比当前元素大或者栈为空(把中间不满足单调性的元素都给踢掉)
		while s and s[-1] <= nums[i]:
			s.pop()
		# 此时如果栈为空，说明当前元素右边没有比它大的元素，填 -1
		# 此时如果栈不为空，说明栈顶元素比当前元素大，栈顶元素就是当前元素右边第一个比它大的元素
		res[i] = -1 if not s else s[-1]
		# 把当前元素压入栈
		s.append(nums[i])
	return res
```

从上面的代码我们了解到，单调栈相比栈要多出的一个特性就是: 在入栈时，主动把栈中不满足单调性的元素给踢掉。

<br>

## 单调队列

同样，队列的原理我们在 [栈与队列](../栈与队列/brief_introduction.md) 中介绍过了，这是一种遵循先入先出的数据结构，底层可以通过数组或者链表实现。单调队列同样在队列的基础上追加了一种特性，就是队列内元素是单调递增或者单调递减的。

具体做法也是当在入队时，主动把不符合单调性的元素给踢掉.

示例代码如下:

```python
# 单调队列的应用 
class MonotonicQueue:
	def __init__(self):
		self.maxq = []
	
	def push(self, n):
		while self.maxq and self.maxq[-1] < n:
			self.maxq.pop()
		self.maxq.append(n)
	
	def max(self):
		return self.maxq[0]
	
	def pop(self, n):
		if n == self.maxq[0]:
			self.maxq.pop(0)
```

**经典应用场景**:

`给你一个数组 window，已知其最值为 A，如果给 window 中添加一个数 B，那么比较一下 A 和 B 就可以立即算出新的最值；但如果要从 window 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 A，就需要遍历 window 中的所有元素重新寻找新的最值`

这个场景很常见，但不用单调队列似乎也可以，比如优先级队列也是一种特殊的队列，专门用来动态寻找最值的，我创建一个大（小）顶堆，不就可以很快拿到最大（小）值了吗？

如果单纯地维护最值的话，优先级队列很专业，队头元素就是最值。但优先级队列无法满足标准队列结构「先进先出」的时间顺序，因为优先级队列底层利用二叉堆对元素进行动态排序，元素的出队顺序是元素的大小顺序，和入队的先后顺序完全没有关系。

所以，现在需要一种新的队列结构，既能够维护队列元素「先进先出」的时间顺序，又能够正确维护队列中所有元素的最值，所以单调队列就派上用场了。
